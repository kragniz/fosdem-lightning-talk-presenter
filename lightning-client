#!/usr/bin/env python3

import json
import sys
import os
import math
import urllib.request
from datetime import datetime, timedelta
from dataclasses import dataclass
from enum import Enum

import gi

gi.require_version("Gtk", "4.0")
gi.require_version("Adw", "1")
from gi.repository import Gtk, Adw, Gdk, Gio, GLib
from gi.repository import Pango, PangoCairo
from gi.repository import Poppler


@dataclass
class Talk:
    title: str
    first_name: str
    last_name: str
    slides_name: str
    slides_url: str


class Session:
    def __init__(self, api_dict):
        self.start = self.get_time_from_field(api_dict, "start")
        self.end = self.get_time_from_field(api_dict, "end")

        talks = api_dict.get("talks")
        self.talks = self.create_talks(talks)

    def get_time_from_field(self, d, field_name):
        timestamp = d.get(field_name).replace("Z", "+00:00")
        return datetime.fromisoformat(timestamp)

    def create_talks(self, json_talks):
        talks = []
        for t in json_talks:
            author = t.get("author", {})
            talks.append(
                Talk(
                    title=t.get("title"),
                    first_name=author.get("first_name"),
                    last_name=author.get("last_name"),
                    slides_name=t.get("slides_name"),
                    slides_url=t.get("slides_url"),
                )
            )
        return talks

    def fetch_talk_slides(self):
        os.makedirs("slides", exist_ok=True)

        for talk in self.talks:
            path = os.path.join("slides", talk.slides_name)
            if not os.path.isfile(path):
                print(f"{path} isn't available locally, fetching...")
                urllib.request.urlretrieve(talk.slides_url, path)


class Mode(Enum):
    INTRO = 1
    TITLE = 2
    PRESENTATION = 3


@dataclass
class State:
    mode: Mode
    current_talk_time_end: datetime
    session: Session
    page: int
    talk: int

    def get_current_talk(self):
        return self.session.talks[self.talk]

    def get_next_talk(self):
        offset = 0
        if self.talk < len(self.session.talks) - 1:
            offset = 1
        return self.session.talks[self.talk + offset]

    def get_current_speaker(self):
        talk = self.get_current_talk()
        return f"{talk.first_name} {talk.last_name}"

    def get_next_speaker(self):
        talk = self.get_next_talk()
        return f"{talk.first_name} {talk.last_name}"


TITLE_FONT = "Inter Bold 20"
TITLE_FONT_DEC = Pango.font_description_from_string(TITLE_FONT)
AUTHOR_FONT = "Inter Normal 10"
AUTHOR_FONT_DEC = Pango.font_description_from_string(AUTHOR_FONT)
DEFAULT_WIDTH = 453.543
DEFAULT_HEIGHT = 255.118


class MainWindow(Adw.ApplicationWindow):
    def __init__(self, state, *args, **kwargs):
        super().__init__(title="Slides", *args, **kwargs)
        self.state = state

        self.is_fullscreen = False
        self.set_default_size(DEFAULT_WIDTH * 2, DEFAULT_HEIGHT * 2)

        evk = Gtk.EventControllerKey.new()
        evk.connect("key-pressed", self.key_press)
        self.add_controller(evk)

        self.dw = Gtk.DrawingArea()

        self.dw.set_hexpand(True)
        self.dw.set_vexpand(True)

        self.dw.set_draw_func(self.draw, None)
        self.set_content(self.dw)

        self.update_talk()

    def update_talk(self):
        self.doc = Poppler.Document.new_from_file(
            "file://"
            + os.path.abspath(
                os.path.join("slides", self.state.get_current_talk().slides_name)
            )
        )
        self.pages_count = self.doc.get_n_pages()
        print(f"got {self.pages_count=}")
        self.update_page()
        print(f"{self.page.get_size()=}")

    def update_page(self):
        print(f"setting page to {self.state.page=}")
        self.page = self.doc.get_page(self.state.page)
        self.page_x, self.page_y = self.page.get_size()
        self.dw.queue_draw()

    def draw(self, area, c, w, h, data):
        if self.state.mode == Mode.INTRO:
            self.draw_intro(area, c, w, h, data)
        if self.state.mode == Mode.PRESENTATION:
            self.draw_presentation(area, c, w, h, data)

    def draw_presentation(self, area, c, w, h, data):
        c.set_source_rgb(0, 0, 0)
        c.paint()

        c.save()
        width_scale = w / self.page_x
        height_scale = h / self.page_y
        if width_scale > height_scale:
            scale = height_scale
        else:
            scale = width_scale

        c.scale(scale, scale)
        try:
            self.page.render(c)
        finally:
            c.restore()

    def draw_intro(self, area, c, w, h, data):
        width_scale = w / DEFAULT_WIDTH
        height_scale = h / DEFAULT_HEIGHT
        if width_scale > height_scale:
            scale = height_scale
        else:
            scale = width_scale
        c.scale(scale, scale)

        c.set_source_rgb(0.9, 0.9, 0.9)
        c.paint()

        c.set_source_rgb(0.1, 0.1, 0.1)

        layout = PangoCairo.create_layout(c)

        talk = self.state.get_current_talk()

        layout.set_text(talk.title, -1)
        layout.set_font_description(TITLE_FONT_DEC)
        layout.set_width(400000)

        c.save()
        c.set_source_rgb(0.1, 0, 0.1)
        c.move_to(25, 100)
        PangoCairo.show_layout(c, layout)
        c.restore()

        layout.set_text(self.state.get_current_speaker(), -1)
        layout.set_font_description(AUTHOR_FONT_DEC)

        c.save()
        c.set_source_rgb(0.3, 0.2, 0.3)
        c.move_to(25, 200)
        PangoCairo.show_layout(c, layout)
        c.restore()

    def toggle_fullscreen(self):
        self.is_fullscreen = not self.is_fullscreen
        if self.is_fullscreen:
            self.fullscreen()
        else:
            self.unfullscreen()

    def key_press(self, event, keyval, keycode, state):
        if keyval == Gdk.KEY_q and state & Gdk.ModifierType.CONTROL_MASK:
            self.destroy()
        elif keyval == Gdk.KEY_f and state & Gdk.ModifierType.CONTROL_MASK:
            self.toggle_fullscreen()
        elif keyval == Gdk.KEY_space or keyval == Gdk.KEY_Right:
            if self.state.mode == Mode.INTRO:
                print("starting presentation")
                self.state.mode = Mode.PRESENTATION
                self.state.current_talk_time_end = datetime.now() + timedelta(minutes=1)
                self.update_page()
            elif self.state.mode == Mode.PRESENTATION:
                self.state.page += 1
                if self.state.page >= self.pages_count:
                    self.state.mode = Mode.INTRO
                    self.state.page = 0
                    self.state.talk += 1
                    self.update_talk()
                else:
                    self.update_page()
        elif keyval == Gdk.KEY_Left:
            print("going back a slide")
            if self.state.mode == Mode.PRESENTATION:
                if self.state.page >= 1:
                    self.state.page -= 1
                    self.update_page()


class PreviewWindow(Adw.ApplicationWindow):
    def __init__(self, state, *args, **kwargs):
        super().__init__(title="Preview", *args, **kwargs)
        self.state = state

        self.set_default_size(DEFAULT_WIDTH * 2, DEFAULT_HEIGHT * 2)

        self.dw = Gtk.DrawingArea()

        self.dw.set_hexpand(True)
        self.dw.set_vexpand(True)

        self.dw.set_draw_func(self.draw, None)
        self.set_content(self.dw)

        def refresh_screen():
            self.dw.queue_draw()
            GLib.timeout_add(1000 / 30, refresh_screen)

        GLib.timeout_add(1000 / 30, refresh_screen)

    def draw(self, area, c, w, h, data):
        width_scale = w / DEFAULT_WIDTH
        height_scale = h / DEFAULT_HEIGHT
        if width_scale > height_scale:
            scale = height_scale
        else:
            scale = width_scale
        c.scale(scale, scale)

        c.set_source_rgb(0, 0, 0)
        c.paint()

        c.set_source_rgb(0.9, 0.9, 0.9)

        talk = self.state.get_next_talk()

        layout = PangoCairo.create_layout(c)
        layout.set_text(f"NEXT SPEAKER:\n{self.state.get_next_speaker()}".upper(), -1)
        layout.set_font_description(TITLE_FONT_DEC)
        layout.set_width(400000)

        c.save()
        c.set_source_rgb(0.9, 0.9, 0.9)
        c.move_to(25, 25)
        PangoCairo.show_layout(c, layout)
        c.restore()

        if self.state.mode == Mode.INTRO:
            layout.set_text(f"PRESS SPACE TO START TALK", -1)
        if self.state.mode == Mode.PRESENTATION:
            time_left = self.state.current_talk_time_end - datetime.now()
            formatted_time = str(time_left).split(".")[0]
            layout.set_text(f"TIME REMAINING: {formatted_time}", -1)

        layout.set_font_description(TITLE_FONT_DEC)
        layout.set_width(500000)

        c.save()
        c.set_source_rgb(0.9, 0.9, 0.9)
        c.move_to(25, 150)
        PangoCairo.show_layout(c, layout)
        c.restore()


class LightningClient(Adw.Application):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.connect("activate", self.on_activate)

        with open("session_1_formatted.json") as f:
            self.session = Session(json.load(f))
        print(self.session.start)
        print(self.session.end)
        self.session.fetch_talk_slides()

        self.state = State(
            mode=Mode.INTRO,
            current_talk_time_end=datetime.now(),
            session=self.session,
            page=0,
            talk=0,
        )

    def on_activate(self, app):
        self.win = MainWindow(state=self.state, application=app)
        self.win.present()

        self.preview_win = PreviewWindow(state=self.state, application=app)
        self.preview_win.present()


app = LightningClient(application_id="org.fosdem.LightningTalkClient")
app.run(sys.argv)
